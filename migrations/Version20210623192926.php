<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20210623192926 extends AbstractMigration
{
    public function getDescription() : string
    {
        return 'Include Lesson 1 in Chapter 1';
    }

    public function up(Schema $schema) : void
    {
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'nombreDeUsuario\'] === \'username\')\n            && ($semanticNames[\'obtenerRepositorios\'] === \'getRepositories\')\n            && ($semanticNames[\'repositorios\'] === \'repositories\')\n            && ($semanticNames[\'título\'] === \'title\')\n            && ($semanticNames[\'obtenerTítulo\'] === \'getTitle\')\n            && ($semanticNames[\'descripción\'] === \'description\')\n            && ($semanticNames[\'obtenerDescripción\'] === \'getDescription\')\n			&& ($semanticNames[\'fechaCreación\'] === \'creationDate\')          \n            && ($semanticNames[\'obtenerFechaCreación\'] === \'getCreationDate\');\n        \n         $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '45');");
        $this->addSql("UPDATE `kata` SET `description` = 'Como ya se ha dicho, los nombres deben ser suficientemente claros y, tanto las abreviaturas como  las palabras del lenguaje de programación, deberían evitarse a la hora de nombrar variables.   \n\nIncluir  palabras como **string**, **float**, **array** u **object** en el nombre de una variable produce el acoplamiento del lenguaje de programación a las reglas del negocio.\n___\nPor ejemplo, imagina que encontramos un listado de usuarios y el nombre de la variables es **“$usersArray”**. En este caso, este grumete acaba de acoplar el tipo de dato al nombre de la variable.\n¿Qué sucece si, con el tiempo, se crea un objeto que contenga ese listado de usuarios y dicho listado  se gestiona mediante métodos? Pues que el nombre **“$usersArray”** llevará a quien lea nuestro código a pensar que esa variable almacena un array cuando en realidad almacena un objeto. Alguien podría pensar en cambiar el nombre a uno más semántico como **“$userObject”**, en cuyo caso yo lo pasaría directamente por la quilla sin pensarlo mucho. \n\nQuizá otro alguien podría pensar en **$userCollection** que, a priori, no nos aporta valor ya que **“collection”** parece una colección pero ¿qué hace una colección?. Lo mejor es llamarle simplemente **$users**.\n\nImagina que igues en el mismo proyecto y has llegado hasta el siguiente código sintiendo un escalofrío en la columna vertebral:\n```\n$endDateString = $product->getEndDate();\n$priceFloat = $product->getPrice();\n$commentsArray = $product->getComments();\n$galleryObject = $product->getGallery();\n\n```\n\n¿Cómo lo refactorizarías para mejorar el código?\n' WHERE (`id` = '47');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'klasses\'] === \'classes\')\n            && ($semanticNames[\'d4te\'] === \'date\')\n            && ($semanticNames[\'name2\'] === \'name\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}' WHERE (`id` = '48');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n        \"klasses\" => \"\",\n        \"d4te\" => \"\",\n        \"name2\" => \"\"\n    ];\n}' WHERE (`id` = '48');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'$pwd\'] === \'$password\')\n            && ($semanticNames[\'$user->getPwd()\'] === \'$user->getPassword()\')\n            && ($semanticNames[\'$this->showInvalidPwdMsg()\'] === \'$this->showInvalidPasswordMessage()\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '51');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n        \"$pwd\" => \"\",\n        \"$user->getPwd()\" => \"\",\n        \"$this->showInvalidPwdMsg()\" => \"\"\n    ];\n}' WHERE (`id` = '51');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n        \'$pwd\' => \'\',\n        \'$user->getPwd()\' => \'\',\n        \'$this->showInvalidPwdMsg()\' => \'\'\n    ];\n}' WHERE (`id` = '51');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n      \'$ord\' => \"\",\n      \'$ymdhms\' => \"\",\n      \'$setCreDat()\' => \"\",\n      \'$this->creDat\' => \"\"\n    ];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$ord\'] === \'$order\')\n            && ($semanticNames[\'$ymdhms\'] === \'$currentDate\')\n            && ($semanticNames[\'$setCreDat()\'] === \'$setCreationDate()\')\n            && ($semanticNames[\'$this->creDat\'] === \'$this->creationDate\');\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}' WHERE (`id` = '53');");
        $this->addSql("UPDATE `kata` SET `description` = 'Imagina que necesitas buscar variables que estén relacionadas con un token. Ahora imagina que los  nombres utilizados para definir variables son algo así:\n\n```\n$tokExpTim\n$ymdhmsTok\n$authTok\n```\nCon estos \"mensajes encriptados\" va ser más complicado encontrar aquellas variables y funciones relacionadas con el código que encontrar la X con el mapa del tesoro. Los nombres que utilizan abreviaturas o son más cortos, acaban por ser más complicados de buscar. Para este caso hubieran sido mejores nombres:\n\n```\n$tokenExpirationTime\n$tokenCreationDate\n$authenticationToken\n```\nImagina que hay un bug en la creación de un pedido y encuentras el siguiente código que crea un pedido y le asigna la fecha en la que se ha creado.\n```\n// Create order\n$ord = new Order();\n\n// Get current date\n$ymdhms = new datetime();\n\n// Set creation date from current date\n$ord->setCreDat($ymdhms);\n\npublic function setCreDat(DateTime $ymdhms): void\n{\n    $this->creDat = $ymdhms;\n}\n```\nTu espíritu pirata se revuelve en tu interior y no puedes evitar refactorizar esos nombres abreviados por otros más **semánticos**.\n' WHERE (`id` = '53');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n      \'$ord\' => \'\',\n      \'$ymdhms\' => \'\',\n      \'$setCreDat()\' => \'\',\n      \'$this->creDat\' => \'\'\n    ];\n}' WHERE (`id` = '53');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n      \'$ord\' => \'\',\n      \'$ymdhms\' => \'\',\n      \'$ord->setCreDat()\' => \'\',\n      \'$this->creDat\' => \'\'\n    ];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$ord\'] === \'$order\')\n            && ($semanticNames[\'$ymdhms\'] === \'$currentDate\')\n            && ($semanticNames[\'$ord->setCreDat()\'] === \'$order->setCreationDate()\')\n            && ($semanticNames[\'$this->creDat\'] === \'$this->creationDate\');\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}' WHERE (`id` = '53');");
        $this->addSql("UPDATE `kata` SET `description` = 'Aunque, en general, los nombres verbosos son mejor opción que los cortos, cualquier nombre es mejor que un maldito número. Habría que pasar por la quilla a aquellos botarates que osaran utilizar un número como variable.\n___\nImagina que trabajas en una plataforma de vídeos en la que, tras registrarse, el usuario tiene que confirmar su cuenta haciendo click en un enlace. El usuario no puede acceder al contenido hasta que no haya confirmado su cuenta por estar *“pendiente de confirmación”*. \n\n```````````````````````````````````````````````````````````````````````````````\nIf ($userStatus == 3) {\n    return $this->pendingConfirmationResponse();\n}\n```````````````````````````````````````````````````````````````````````````````\nComo buen pirata codificador, ese 3 debería sustituirse por una constante (de esa misma clase) con un nombre lo suficientemente semántico.\n\n**Nota: recuerda que los nombres de las constantes se escriben en mayúscula con un guión bajo si hay espacios.**\n\nPor ejemplo, para un estado de usuario borrado se podría sustituir el número mágico por \"self::USER_STATUS_DELETED\".\n', `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'3\' => \'\'\n      ];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'3\'] === \'self::USER_STATUS_PENDING_CONFIRMATION\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '55');");
        $this->addSql("UPDATE `kata` SET `description` = 'Es posible que, en determinadas ocasiones, se considere añadir información extra para indicar el tipo de variable como por ejemplo:\n```\n$usersArray\n$dateString\n```\nO quizá indicar la visibilidad de las mismas con un ingenioso prefijo:\n```\n$_date: variable privada.\n$p_date: variable privada.\n\n```\nTodo esto es un auténtico excremento de gaviota y, salvo que trabajes en papiro, los IDE actuales son capaces de resolver este tipo de problemas, así como la ejecución del código que resultará en un error de tipo o de acceso.\n___\nImagina que tienes el siguiente código:\n\n```````````````````````````````````````````````````````````````````````````````\n$creationDateString = $creationDate->format(‘Y-m-d’);\n$this->str_email = $email;\n$this->str_password = $password;\n$this->txt_aboutMe = $aboutMe;\n$this->int_favouriteNumber = $favouriteNumber;\n```````````````````````````````````````````````````````````````````````````````\n\nRefactoriza los nombres de variables antes de que me sangren más los ojos.', `editor_code` = 'function getSemanticNames(): array\n{\n  return [\n    \'$creationDateString\' => \'\',\n    \'$this->str_email\' => \'\',\n    \'$this->str_password\' => \'\',\n    \'$this->txt_aboutMe\' => \'\',\n    \'$this->int_favouriteNumber\' => \'\'\n    ];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$creationDateString\'] === \'$creationDate\')\n            && ($semanticNames[\'$this->str_email\'] === \'$this->email\')\n            && ($semanticNames[\'$this->str_password\'] === \'$this->password\')\n            && ($semanticNames[\'$this->txt_aboutMe\'] === \'$this->aboutMe\')\n            && ($semanticNames[\'$this->int_favouriteNumber\'] === \'$this->favouriteNumber\');\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '57');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$u\' => \'\',\n      \'$un\' => \'\',\n      \'$tmp\' => \'\',\n      \'$e\' => \'\'\n	];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$u\'] === \'$url\')\n            && ($semanticNames[\'$un\'] === \'$username\')\n            && ($semanticNames[\'$tmp\'] === \'$temperature\')\n            && ($semanticNames[\'$e\'] === \'$exception\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '59');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$itemsData\' => \'\',\n      \'$billInfo\' => \'\',\n      \'$shipAddInfo\' => \'\'\n	];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$itemsData\'] === \'$items\')\n            && ($semanticNames[\'$billInfo\'] === \'$bill\')\n            && ($semanticNames[\'$shipAddInfo\'] === \'$shipmentAddress\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}' WHERE (`id` = '60');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->remTag()\' => \'\',\n      \'$post->pubFutDat()\' => \'\',\n      \'$post->published()\' => \'\'\n    ];         \n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'$post->remTag()\'] === \'$post->removeTag()\')\n            && ($semanticNames[\'$post->pubFutDat()\'] === \'$post->publishAtFutureDate()\')\n            && ($semanticNames[\'$post->published()\'] === \'$post->isPublished()\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '61');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'$post->remTag()\'] === \'$post->removeTag()\')\n            && ($semanticNames[\'$post->pubFutDat($publicationDate)\'] === \'$post->publishAtFutureDate($publicationDate)\')\n            && ($semanticNames[\'$post->published()\'] === \'$post->isPublished()\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '61');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->remTag()\' => \'\',\n      \'$post->pubFutDat($publicationDate)\' => \'\',\n      \'$post->published()\' => \'\'\n    ];         \n}' WHERE (`id` = '61');");
        $this->addSql("UPDATE `kata` SET `description` = 'Si los nombres son producto de alguna broma o gracia del momento, ésta sólo tendrá sentido para aquellos que la conozcan. Si un programador al que no le gustan los videojuegos se encuentra en la clase User con un método FinishHim() a lo Mortal Kombat, lo más probable es que no entienda el método hasta que no investigue un poco el contexto. El nombre delete() es un nombre más **semántico** que todo el mundo puede entender.  \n\nImagina que tienes una aplicación blog donde encuentras los siguientes métodos:\n```\n// Remove a tag\n$post->obliviate($tag);\n\n// Publish post at a publication date\n$post->ascendioPostAt($publicationDate);\n\n// Show formatted Post\n$formattedPost = $post->accioPost();\n\n```\nAl parecer el grumete de agua dulce que escribió este código ha visto muchas películas de un cierto mago. Refactorízalo antes de que te salga la marca de un rayo en la frente.', `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->obliviate()\' => \'\',\n      \'$post->ascendioPostAt($publicationDate)\' => \'\',\n      \'$post->accioPost()\' =>  \'\',\n     ];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->obliviate()\'] === \'$post->remove()\')\n            && ($semanticNames[\'$post->ascendioPostAt()\'] === \'$post->publishPostAt($publicationDate)\')\n            && ($semanticNames[\'$post->accioPost()\'] === \'$post->showFormattedPost()\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '62');");
        $this->addSql("UPDATE `kata` SET `description` = 'Si los nombres son producto de alguna broma o gracia del momento, ésta sólo tendrá sentido para aquellos que la conozcan. Si un programador al que no le gustan los videojuegos se encuentra en la clase User con un método FinishHim() a lo Mortal Kombat, lo más probable es que no entienda el método hasta que no investigue un poco el contexto. El nombre delete() es un nombre más **semántico** que todo el mundo puede entender.  \n\nImagina que tienes una aplicación blog donde encuentras los siguientes métodos:\n```\n// Remove a tag\n$post->obliviate($tag);\n\n// Publish post at a publication date\n$post->ascendioPostAt($publicationDate);\n\n// Add comment to post\n$formattedPost = $post->accioComment($comment);\n\n```\nAl parecer el grumete de agua dulce que escribió este código ha visto muchas películas de un cierto mago. Refactorízalo antes de que te salga la marca de un rayo en la frente.', `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->obliviate()\' => \'\',\n      \'$post->ascendioPostAt($publicationDate)\' => \'\',\n      \'$post->accioComment($comment)\' =>  \'\',\n     ];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->obliviate()\'] === \'$post->remove()\')\n            && ($semanticNames[\'$post->ascendioPostAt()\'] === \'$post->publishPostAt($publicationDate)\')\n            && ($semanticNames[\'$post->accioComment($comment)\'] === \'$post->addComment($comment)\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '62');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->obliviate($tag)\' => \'\',\n      \'$post->ascendioPostAt($publicationDate)\' => \'\',\n      \'$post->accioComment($comment)\' =>  \'\',\n     ];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->obliviate($tag)\'] === \'$post->remove($tag)\')\n            && ($semanticNames[\'$post->ascendioPostAt()\'] === \'$post->publishPostAt($publicationDate)\')\n            && ($semanticNames[\'$post->accioComment($comment)\'] === \'$post->addComment($comment)\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '62');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->obliviate($tag)\'] === \'$post->remove($tag)\')\n            && ($semanticNames[\'$post->ascendioPostAt($publicationDate)\'] === \'$post->publishPostAt($publicationDate)\')\n            && ($semanticNames[\'$post->accioComment($comment)\'] === \'$post->addComment($comment)\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '62');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->obliviate($tag)\'] === \'$post->remove($tag)\')\n            && ($semanticNames[\'$post->ascendioPostAt($publicationDate)\'] === \'$post->publishAt($publicationDate)\')\n            && ($semanticNames[\'$post->accioComment($comment)\'] === \'$post->addComment($comment)\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}\n' WHERE (`id` = '62');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$post->retrievePublicationDate()\' => \'\',\n      \'$comment->fetchCreationDate()\' => \'\',\n      \'$post->loadCreationDate()\' => \'\',\n      \'$comment->putCreationDate()\' => \'\',\n      \'$postsRepository->lookForAll()\'=> \'\',\n      \'$commentsRepository->searchAll()\' => \'\'\n    ];\n}\n', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$post->retrievePublicationDate()\'] === \'$post->getPublicationDate()\')\n&& ($semanticNames[\'$comment->fetchCreationDate()\'] === \'$comment->getCreationDate()\')\n&& ($semanticNames[\'$post->loadCreationDate()\'] === \'$post->setCreationDate()\')\n&& ($semanticNames[\'$comment->putCreationDate()\'] === \'$comment->setCreationDate()\')\n&& ($semanticNames[\'$postsRepository->lookForAll()\'] === \'$postsRepository->findAll()\')\n&& ($semanticNames[\'$commentsRepository->searchAll()\'] === \'$commentsRepository->findAll()\');\n\n   	 \n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}' WHERE (`id` = '83');");
        $this->addSql("UPDATE `kata` SET `editor_code` = 'function getSemanticNames(): array\n{\n    return [\n      \'$unpbil\' => \'\',\n      \'$sorUnpBilByAmoDes\' => \'\',\n      \'$fuckingDefaulters\' => \'\',\n      \'$df\' => \'\',\n      \'$poen\' => \'\'\n    ];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'$unpbil\'] === \'$unpaidBill\')\n          && ($semanticNames[\'$sorUnpBilByAmoDes\'] === \'$sortedUnpaidBillsByDescendingAmount\')\n          && ($semanticNames[\'$fuckingDefaulters\'] === \'$defaulters\')\n          && ($semanticNames[\'$df\'] === \'$defaulter\')\n          && ($semanticNames[\'$poen\'] === \'$pendingOrderEmailNotification\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '85');");
        $this->addSql("UPDATE `kata` SET `description` = 'El dominio del problema es el lenguaje que se utiliza para describir el problema que queremos resolver sin entrar en la parte técnica.   \n \nPor ejemplo, el desarrollo de un proceso que envíe notificaciones por correo electrónico a clientes que tengan la última factura pendiente de pago, enviando dichas notificaciones por orden de deuda acumulada, siendo los primero los que más deuda acumulada tengan.\n\nEl dominio del problema puede estar compuesto por conceptos como: *notificación*, *correo electrónico*, *facturas*, *pendientes de pagar*.\n\nSe quiere enviar una serie de notificaciones por correo electrónico a clientes que tienen facturas impagadas. Para ello, en primer lugar, se obtienen todos aquellos clientes que tengan al menos una factura impagada. El orden de las notificaciones dependerá de la deuda que tenga el cliente. A más deuda más prioridad por lo que hay que ordenar el listado de impagos. \n\nEsta funcionalidad está encapsulada en la clase siguiente:\n```\n// Find all unpaid bills\n$unpbil = $billsRepository->findUnpaidBills();\n\n// Sort unpaid bills by descending amount\n$sorUnpBilBDesAmo = $this->sortByDescAmo($unpbil)\n\n// Get defaulters \n$fuckingDefaulters =  $this->getDefaulters($sUnpBil);\n\nforeach($fuckingDefaulters as $df) {\n    // Sent notification\n    $poen = new PendingOrderEmailNotification();\n    $poen->setToEmail($fd->getEmail());\n    $poen->send();\n}\n\n```\n¿Qué nombres del dominio se deberían haber elegido?\n' WHERE (`id` = '85');");
        $this->addSql("UPDATE `kata` SET `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n    function testKata()\n    {\n        $kataSourceCode= new KataSourceCode();\n        $semanticNames = $kataSourceCode->getSemanticNames();\n\n        $areSemanticNamesValid = ($semanticNames[\'$unpbil\'] === \'$unpaidBills\')\n          && ($semanticNames[\'$sorUnpBilByAmoDes\'] === \'$sortedUnpaidBillsByDescendingAmount\')\n          && ($semanticNames[\'$fuckingDefaulters\'] === \'$defaulters\')\n          && ($semanticNames[\'$df\'] === \'$defaulter\')\n          && ($semanticNames[\'$poen\'] === \'$pendingOrderEmailNotification\');\n        \n        $this->assertTrue($areSemanticNamesValid);\n    }\n}\n' WHERE (`id` = '85');");
        $this->addSql("UPDATE `kata` SET `description` = 'Cuando se elige un nombre semántico para una variable, éste no tiene un significado específico si no está incluido en un contexto concreto. \nPor ejemplo, la variable **$status** hace referencia a un estado pero si se tienen varias entidades en la misma función no se sabría a cuál de ellas se está haciendo referencia salvo retrocediendo en el código.\n\nEn aquellos casos en los que el código quede ambiguo, es más que recomendable refactorizar el nombre incluyendo el nombre de la entidad, como por ejemplo $userStatus o $postStatus. De esta manera no cabe duda de a qué entidad está haciendo referencia esa propiedad.\n\nUna solución aún mejor sería incluir ese atributo en la clase User o la clase Post para acceder al mismo a través de un método getStatus con lo que también estaríamos eliminando la ambigüedad:\n```\n$user->getStatus();\n$post->getStatus();\n```\n___\nImagina que tienes el siguiente código y solo tienes dos opciones: refactorizar el código o emborracharte con grog. Opta por lo primero que da menos resaca.\n```\n$status = $user->getStatus();\n\n// Check if user’s status is pending to confirm \nIf ($status == 2) {\n    throw new StatusUserIsPendingToConfirm();    \n}\n\n$status2 = $post->getStatus();\n// Check if status post is a draft\nIf ($status2 == 3) {\n    throw new StatusPostIsADraft();\n}\n```\nEs recomendable evitar los números mágicos y convertirlos en constantes que contengan ese número. Para este proyecto se ha adoptado la convención de nombrar las constantes con mayúsculas y notación underscore. \n\n**Nota: el nombre de estas constantes debería describir el nombre de la entidad y el estado de la misma.**\n', `editor_code` = 'function getSemanticNames(): array\n{\n	return [\n      \'$status\' => \'\',\n      \'2\' => \'\',\n      \'$status2\' => \'\',\n      \'3\' => \'\',\n     ];\n}', `kata_test_code` = '<?php\nnamespace PhpunitExecutionFromPhpTemporary;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass KataTest extends TestCase\n{\n	function testKata()\n	{\n    	$kataSourceCode= new KataSourceCode();\n    	$semanticNames = $kataSourceCode->getSemanticNames();\n\n    	$areSemanticNamesValid = ($semanticNames[\'$status\'] === \'$userStatus\')\n		&& ($semanticNames[\'2\'] === \'UserStatus::PENDING_TO_CONFIRM\')\n		&& ($semanticNames[\'$status2\'] === \'$postStatus\')\n		&& ($semanticNames[\'3\'] === \'PostStatus::DRAFT\');\n    	$this->assertTrue($areSemanticNamesValid);\n	}\n}' WHERE (`id` = '86');");
        $this->addSql("UPDATE `kata` SET `description` = 'Cuando se elige un nombre semántico para una variable, éste no tiene un significado específico si no está incluido en un contexto concreto. \nPor ejemplo, la variable **$status** hace referencia a un estado pero si se tienen varias entidades en la misma función no se sabría a cuál de ellas se está haciendo referencia salvo retrocediendo en el código.\n\nEn aquellos casos en los que el código quede ambiguo, es más que recomendable refactorizar el nombre incluyendo el nombre de la entidad, como por ejemplo $userStatus o $postStatus. De esta manera no cabe duda de a qué entidad está haciendo referencia esa propiedad.\n\nUna solución aún mejor sería incluir ese atributo en la clase User o la clase Post para acceder al mismo a través de un método getStatus con lo que también estaríamos eliminando la ambigüedad:\n```\n$user->getStatus();\n$post->getStatus();\n```\n___\nImagina que tienes el siguiente código y solo tienes dos opciones: refactorizar el código o emborracharte con grog. Opta por lo primero que da menos resaca.\n```\n$status = $user->getStatus();\n\n// Check if user’s status is pending to confirm \nIf ($status == 2) {\n    throw new StatusUserIsPendingToConfirm();    \n}\n\n$status2 = $post->getStatus();\n// Check if status post is a draft\nIf ($status2 == 3) {\n    throw new StatusPostIsADraft();\n}\n```\nEs recomendable evitar los números mágicos y convertirlos en constantes que contengan ese número. Para este proyecto se ha adoptado la convención de nombrar las constantes con mayúsculas y notación underscore. \n\n**Nota: el nombre de estas constantes debería utilizar el nombre de la entidad que representa los distintos estados y el valor del estado. Por ejemplo, para un estado de un pedido podría ser \"OrderStatus::CONFIRMED\".**\n' WHERE (`id` = '86');");
    }

    public function down(Schema $schema) : void
    {
        // this down() migration is auto-generated, please modify it to your needs

    }
}
